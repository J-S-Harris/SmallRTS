package levels;

import java.util.ArrayList;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;

import monsters.MonsterBaseClass;
import monsters.MonsterFastStrong;
import monsters.MonsterWeakSlow;

public class LevelManager {

	// Overall class variables
	ArrayList<MonsterBaseClass> enemiesThisTurn;
	int currentLevel;
	int movementCounter;
	SpriteBatch batch;
	int nextTurnDelay;
	int nextTurnDelayValue;

	// Instance variables for generating monsters;
	int quantity;
	int count;
	double startingY;

	public LevelManager(SpriteBatch batch) {
		this.batch = batch;
		enemiesThisTurn = new ArrayList<MonsterBaseClass>();
		currentLevel = 0;

		startNewTurn();
		
		nextTurnDelay = 0;
		nextTurnDelayValue = 30;

	}

	public void startNewTurn() {
		movementCounter = 0;
		currentLevel++;
		enemiesThisTurn.clear();


		populateVerySlowVeryStrong();
		populateWeakSlow();
		populateFastStrong();

		setStartingPositions();

	}

	public void runTurn() {

		if (enemiesThisTurn.size() == 0) {
			startNewTurn();
		}
		
		if (nextTurnDelay == 0) {

			checkForKills();

			moveEachEnemy();

			checkIfTurnOver();

		} else {
			nextTurnDelay--;
		}

	}

	private void checkIfTurnOver() {
		if (enemiesThisTurn.size() == 0) {
			nextTurnDelay = nextTurnDelayValue;
			System.out.println("Turn over!");
		}

	}

	private void checkForKills() {
		
		for (MonsterBaseClass monster : enemiesThisTurn) {

			if (monster.getRemainingHP() < 1) {
				monster.setAlive(false);
				enemiesThisTurn.remove(monster);
			} else if (movementCounter % monster.getMovementDelay() == 0) {
					monster.setRemainingHP(monster.getRemainingHP() - 1);
					System.out.println("REM HP: " + monster.getRemainingHP());
				}
			}
		}

	private void moveEachEnemy() {

		if (enemiesThisTurn.size() > 0) {
			if (movementCounter >= 360) {
				movementCounter = 0;
			}
			movementCounter++;

			for (MonsterBaseClass monster : enemiesThisTurn) {
				if (movementCounter % monster.getMovementDelay() == 0) {
					monster.x -= monster.getMovementSpeed();
				}
				if (monster.getRemainingHP() > 0) {
					batch.draw(monster.getSprite(), monster.x, monster.y);
				}
			}

		}

	}

	private void setStartingPositions() {

		// How randomise this array so that they don't come out in a set order?
		for (MonsterBaseClass monster : enemiesThisTurn) {

			monster.x = 725;

			startingY = Math.random() * 3;
			if (startingY > 2) {
				monster.y = 300;
			} else if (startingY > 1) {
				monster.y = 200;
			} else {
				monster.y = 100;
			}

			for (MonsterBaseClass overlapMonster : enemiesThisTurn) {
				if (monster.x == overlapMonster.x && monster.y == overlapMonster.y && monster != overlapMonster) {
					monster.x += 40;
				}
			}
			System.out.println("MONSTER X: " + monster.x);

		}

	}

	public void before() {

		quantity = currentLevel * currentLevel + 1;
		count = 0;
	}

	private void populateWeakSlow() {
		before();

		while (count < quantity) {
			count++;
			enemiesThisTurn.add(new MonsterWeakSlow());
		}

	}

	private void populateFastStrong() {

		before();

		while (count < quantity) {
			count++;
			if (count % 2 == 0) {
				enemiesThisTurn.add(new MonsterFastStrong());
			}
		}

	}

	private void populateVerySlowVeryStrong() {
		before();

		while (count < quantity) {
			count++;
			if (count % 3 == 0) {
				enemiesThisTurn.add(new MonsterFastStrong());
			}
		}

	}
}
