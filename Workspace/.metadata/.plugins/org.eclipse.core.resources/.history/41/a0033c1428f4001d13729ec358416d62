package levels;

import java.util.ArrayList;

import com.badlogic.gdx.graphics.g2d.SpriteBatch;

import monsters.MonsterBaseClass;
import monsters.MonsterFastStrong;
import monsters.MonsterWeakSlow;

public class LevelManager {

	// Overall class variables
	ArrayList<MonsterBaseClass> enemiesThisTurn;
	int currentLevel;
	int movementCounter;
	SpriteBatch batch;

	// Instance variables for generating monsters;
	int quantity;
	int count;
	double startingY;

	public LevelManager(SpriteBatch batch) {
		this.batch = batch;
		enemiesThisTurn = new ArrayList<MonsterBaseClass>();
		currentLevel = 0;
		
		startNewTurn();
		
	}

	public void startNewTurn() {
		movementCounter = 0;
		currentLevel++;
		enemiesThisTurn.clear();

		populateVerySlowVeryStrong();
		populateWeakSlow();
		populateFastStrong();

		setStartingPositions();
	}

	public void runTurn() {
		
		checkForKills();
		
		moveEachEnemy();

	}

	private void checkForKills() {
		for (MonsterBaseClass monster : enemiesThisTurn) {
			
			if (movementCounter % monster.getMovementDelay() == 0) {
				monster.setRemainingHP(monster.getRemainingHP()-1);
				System.out.println("REM HP: "+monster.getRemainingHP());
				if (monster.getRemainingHP() < 1) {
					monster=null;
					monster.getSprite().dispose();
				}
			}
			
		}
		
	}

	private void moveEachEnemy() {
				
		if (enemiesThisTurn.size() > 0) {
			if (movementCounter >= 360) {
				movementCounter = 0;
			}
			movementCounter++;

			for (MonsterBaseClass monster : enemiesThisTurn) {
				if (movementCounter % monster.getMovementDelay() == 0) {
					monster.setRemainingHP(monster.getRemainingHP()-1);
					monster.x -= monster.getMovementSpeed();
				}
				batch.draw(monster.getSprite(), monster.x, monster.y);
			}

		}
		
	}

	private void setStartingPositions() {
		
		// How randomise this array so that they don't come out in a set order?
		for (MonsterBaseClass monster : enemiesThisTurn) {
			
			monster.x = 725;
			
			startingY = Math.random() * 3;
			if (startingY > 2) {
				monster.y = 300;
			} else if (startingY > 1) {
				monster.y = 200;
			} else {
				monster.y = 100;
			}
			
			for (MonsterBaseClass overlapMonster : enemiesThisTurn) {
				if (monster.x == overlapMonster.x
						&& monster.y == overlapMonster.y
						&& monster != overlapMonster) {
					monster.x += 40;
				}
			}
			System.out.println("MONSTER X: "+monster.x);
			
		}

	}

	public void before() {

		quantity = currentLevel * currentLevel + 1;
		count = 0;
	}

	private void populateWeakSlow() {
		before();

		while (count < quantity) {
			count++;
			enemiesThisTurn.add(new MonsterWeakSlow());
		}

	}

	private void populateFastStrong() {

		before();

		while (count < quantity) {
			count++;
			if (count % 2 == 0) {
				enemiesThisTurn.add(new MonsterFastStrong());
			}
		}

	}

	private void populateVerySlowVeryStrong() {
		before();

		while (count < quantity) {
			count++;
			if (count % 3 == 0) {
				enemiesThisTurn.add(new MonsterFastStrong());
			}
		}

	}
}
