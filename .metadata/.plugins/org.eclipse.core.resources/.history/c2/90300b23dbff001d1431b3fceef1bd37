package screensEtc;

import java.util.ArrayList;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.mygdx.smallrts.gameElements.BaseRootClass;
import com.mygdx.smallrts.gameElements.MineRootClass;
import com.mygdx.smallrts.gameElements.PuckRootClass;
import com.mygdx.smallrts.gameElements.StoneChest;

import levels.LevelManager;
import monsters.MonsterBaseClass;
import towers.Barbs;
import towers.BaseTowerClass;
import towers.BasicTower;

public class GameScreen implements Screen {

	MenuScreen game;
	
	SpriteBatch batch;
	BitmapFont font;
	FitViewport viewport;
	OrthographicCamera camera;

	int pointsLeftTeam;
	int pointsRightTeam;

	Screen gameScreen;

	Texture background;

	// For tracking current inputs
	String currentInputsLeft;
	String currentInputsRight;

	// Game elements
	// TODO - Refactor these both so I have a single ArrayList of (arraylist of?)
	// all pucks to act on
	ArrayList<PuckRootClass> leftTeam;
	PuckRootClass puckLeft1;
	PuckRootClass puckLeft2;
	PuckRootClass puckLeft3;
	BaseRootClass baseLeft;
	MineRootClass mineLeft;

	ArrayList<PuckRootClass> rightTeam;
	PuckRootClass puckRight1;
	PuckRootClass puckRight2;
	PuckRootClass puckRight3;
	BaseRootClass baseRight;
	MineRootClass mineRight;
	StoneChest stoneChest;

	// Movement Speed
	int movementSpeed;

	// Gold gained by each team
	int leftTeamGold;
	int rightTeamGold;

	// Points earned by each team so far
	int leftTeamPoints;
	int rightTeamPoints;

	// Stone gathered
	int stoneGathered;

	// Lives in solo mode
	int lives;

	// Left team sprites
	Texture leftTeamNoGold = new Texture(Gdx.files.internal("puckLightBlue.png"));
	Texture leftTeamWithGold = new Texture(Gdx.files.internal("puckLightBlue-Gold.png"));

	// Set up LevelManager
	LevelManager levelManager;

	public GameScreen(MenuScreen menuScreen) {

		this.game = menuScreen;
		
		setUpThings();
		createAllElements();

		assignStartingPositions(leftTeam);
//		assignStartingPositions(rightTeam);

		levelManager = new LevelManager(this, batch);
		
		// Starting Towers:
		addStartingTowers();

	}

	@Override
	public void show() {
		// TODO Auto-generated method stub

	}

	@Override
	public void render(float delta) {

		// Progress one turn

		ScreenUtils.clear(0, 1, 0, 1);

//		viewport.apply();

		check123Pressed(); // Check if 1/2/3 are pressed to see which units will be given orders this frame
		assignPuckAction(); // Update their current behaviour
		performActions();

		// Check for unit/monster collisions; monster/tower collisions are done in
		// LevelManager
		checkForCollisionsUnits();

		batch.begin();

		// After all actions are performed, draw updated positions, points, etc
		drawGameUnits();

		// Display left team's gold + points
//		font.draw(batch, "POINTS\n", 20, 382);
//		font.draw(batch, Integer.toString(leftTeamPoints), 20, 365);
		font.draw(batch, "Remaining Citizens:\n", background.getWidth() / 8, background.getHeight() - 50);
		font.draw(batch, Integer.toString(lives), background.getWidth() / 8 + 150, background.getHeight() - 50);

		font.draw(batch, "GOLD\n", 20, background.getHeight() - 20);
		font.draw(batch, Integer.toString(leftTeamGold), 85, background.getHeight() - 20);

		font.draw(batch, "STONE\n", 15, background.getHeight() - 50);
		font.draw(batch, Integer.toString(stoneGathered), 85, background.getHeight() - 50);

		font.draw(batch, "LEVEL:", 330, background.getHeight() - 50);
		font.draw(batch, Integer.toString(levelManager.getCurrentLevel()), 400, background.getHeight() - 50);

//		// Display right team's gold + points
//		font.draw(batch, "POINTS\n", 625, 382);
//		font.draw(batch, Integer.toString(rightTeamPoints), 660, 365);
//
//		font.draw(batch, "GOLD\n", 640, 45);
//		font.draw(batch, Integer.toString(rightTeamGold), 660, 28);

		// Move monsters; draw monsters
		levelManager.runTurn();

		batch.end();

	}

	private void checkForCollisionsUnits() {

		for (PuckRootClass puck : leftTeam) {

			for (MonsterBaseClass monster : levelManager.getEnemiesThisTurn()) {

				if (puck.overlaps(monster)) {

					if (puck.x < monster.x) {
						puck.x -= (monster.getWeight() - puck.getWeight()) * 5;
						monster.x -= puck.getWeight() - monster.getWeight();
						monster.setRemainingHP(monster.getRemainingHP() - 1);
					}
				}
			}
		}
	}

	private void performActions() {

		for (PuckRootClass puck : leftTeam) {
			performActionsLeft(puck);
		}

//		for (PuckRootClass puck : rightTeam) {
//			performActionsRight(puck);
//		}

	}

	private void performActionsLeft(PuckRootClass puck) {

		switch (puck.getCurrentAction().split("-")[0]) {
		case "FollowInputs":
			followInputs(puck);
			break;
		case "MineGold":
			gatherResource(puck, mineLeft);
			break;
		case "GatherStone":
			gatherResource(puck, stoneChest);
			break;
		case "AttackEnemyBase":
			attackEnemyBase(puck);
			break;
		case "Move300":
			move300(puck);
			break;
		case "Move200":
			move200(puck);
			break;
		case "Move100":
			move100(puck);
			break;
		case "AttackNearest":
			targetNearest(puck);
			break;
		case "pursueLocatedTarget":
			pursueLocatedTarget(puck);
			break;
		case "Build":
			buildTower(puck, puck.getCurrentAction().split("-")[1]);
			break;
		}
	}

	private void pursueLocatedTarget(PuckRootClass puck) {

		if (puck.getTargetMonster().getRemainingHP() < 1 && levelManager.getEnemiesThisTurn().size() != 0) {
			targetNearest(puck);
		}

		puck.setTargetX(puck.getTargetMonster().x);
		puck.setTargetY(puck.getTargetMonster().y);
		homeIn(puck);

	}

	private void targetNearest(PuckRootClass puck) {

		MonsterBaseClass currentTarget = null;
		double referenceX = 1000000000;
		double referenceY = 1000000000;

		double tempX = 0;
		double tempY = 0;

		for (MonsterBaseClass monster : levelManager.getEnemiesThisTurn()) {

			tempX = (puck.x - monster.x) * (puck.x - monster.x);
			tempY = (puck.y - monster.y) * (puck.y - monster.y);

			if (tempX < referenceX && tempY < referenceY) {
				referenceX = tempX;
				referenceY = tempY;
				currentTarget = monster;
			}

		}
		puck.setTargetMonster(currentTarget);
		puck.setCurrentAction("pursueLocatedTarget");

	}

	private void buildTower(PuckRootClass puck, String towerToBuild) {

		// TODO Rewrite: Start by instantiating the correct class,
//			THEN perform gold cost check and position on screen

		switch (towerToBuild) {
		case "BasicTower":

			BasicTower basicTower = new BasicTower();

			if (leftTeamGold >= basicTower.getGoldToMake()) {
				leftTeamGold -= basicTower.getGoldToMake();
				basicTower.x = puck.x;
				basicTower.y = puck.y;
				checkForTowerOverlap(basicTower);
				levelManager.getTowersInPlay().add(basicTower);
				puck.setCurrentAction("FollowInputs");
			}
			break;

		case "BarbedWire":
			Barbs barbedWire = new Barbs();

			if (leftTeamGold >= barbedWire.getGoldToMake()) {

				leftTeamGold -= barbedWire.getGoldToMake();
				barbedWire.x = puck.x;
				barbedWire.y = puck.y;
				checkForTowerOverlap(barbedWire);
				levelManager.getTowersInPlay().add(barbedWire);
				puck.setCurrentAction("FollowInputs");
			}
		}
	}

	private void checkForTowerOverlap(BaseTowerClass tower) {

		for (BaseTowerClass existingTower : levelManager.getTowersInPlay()) {
			if (tower.x == existingTower.x && tower.y == existingTower.y) {
				tower.x -= 10;
				tower.y -= 10;
				break;
			}
		}

	}

	private void attackEnemyBase(PuckRootClass puck) {

		// If not overlapping mine OR base: travel there
		if (puck.getGoldCurrentlyHeld() < 1 && !puck.overlaps(baseRight)) {
			puck.setTargetX((int) (baseRight.x + baseRight.width / 2));
			puck.setTargetY((int) (baseRight.y + baseRight.height / 2));
		} else if (puck.getGoldCurrentlyHeld() > 0 && !puck.overlaps(baseLeft)) {
			puck.setTargetX((int) (baseLeft.x + baseLeft.width / 2));
			puck.setTargetY((int) (baseLeft.y + baseLeft.height / 2));

			// If you no gold at the mine, or have gold at the base: mine/deposit it
		} else if ((puck.getGoldCurrentlyHeld() < 1 && puck.overlaps(baseRight))) {
			puck.setGoldCurrentlyHeld(puck.getGoldCurrentlyHeld() + 5);
			rightTeamGold -= 5;
			puck.setSprite(2);

		} else if ((puck.getGoldCurrentlyHeld() > 0 && puck.overlaps(baseLeft))) {

			if (leftTeamGold < 100) {
				leftTeamGold += 5;
			}
			puck.setGoldCurrentlyHeld(puck.getGoldCurrentlyHeld() - 5);
			puck.setBackground(leftTeamNoGold);

			// If you have no gold at the base, or have gold at the mine: travel to the
			// other one
		} else if ((puck.getGoldCurrentlyHeld() < 1 && puck.overlaps(baseLeft))) {
			puck.setTargetX((int) (baseRight.x + baseRight.width / 2));
			puck.setTargetY((int) (baseRight.y + baseRight.height / 2));

		} else if ((puck.getGoldCurrentlyHeld() > 0 && puck.overlaps(baseRight))) {
			puck.setTargetX((int) (baseLeft.x + baseLeft.width / 2));
			puck.setTargetY((int) (baseLeft.y + baseLeft.height / 2));
		}

		homeIn(puck);

	}

	private void move100(PuckRootClass puck) {

		if (puck.x < 290 || puck.x > 305) {
			puck.setTargetX(300);
		} else {
			puck.setTargetX(0);
		}

		if (puck.y < 90 || puck.y > 105) {
			puck.setTargetY(100);
		} else {
			puck.setTargetY(0);
		}

		homeIn(puck);

	}

	private void move200(PuckRootClass puck) {

		if (puck.x < 290 || puck.x > 305) {
			puck.setTargetX(300);
		} else {
			puck.setTargetX(0);
		}

		if (puck.y < 190 || puck.y > 205) {
			puck.setTargetY(200);
		} else {
			puck.setTargetY(0);
		}

		homeIn(puck);

	}

	private void move300(PuckRootClass puck) {

		if (puck.x < 290 || puck.x > 305) {
			puck.setTargetX(300);
		} else {
			puck.setTargetX(0);
		}

		if (puck.y < 290 || puck.y > 305) {
			puck.setTargetY(300);
		} else {
			puck.setTargetY(0);
		}

		homeIn(puck);
	}

	private void gatherResource(PuckRootClass puck, Rectangle targetBuilding) {

		// If not overlapping mine OR base: travel there

		if (targetBuilding == mineLeft) {

			if (puck.getGoldCurrentlyHeld() < 1 && !puck.overlaps(targetBuilding)) {
				puck.setTargetX((int) (targetBuilding.x + targetBuilding.width / 2));
				puck.setTargetY((int) (targetBuilding.y + targetBuilding.height / 2));
			} else if (puck.getGoldCurrentlyHeld() > 0 && !puck.overlaps(baseLeft)) {
				puck.setTargetX((int) (baseLeft.x + baseLeft.width / 2));
				puck.setTargetY((int) (baseLeft.y + baseLeft.height / 2));

				// If you no gold at the mine, or have gold at the base: mine/deposit it
			} else if ((puck.getGoldCurrentlyHeld() < 1 && puck.overlaps(targetBuilding))) {

				puck.setGoldCurrentlyHeld(puck.getGoldCurrentlyHeld() + 1);
				puck.setSprite(2);
			} else if ((puck.getGoldCurrentlyHeld() > 0 && puck.overlaps(baseLeft))) {

				if (targetBuilding == mineLeft) {
					leftTeamGold += puck.getGoldCurrentlyHeld();
					puck.setGoldCurrentlyHeld(0);
				}
				if (targetBuilding == stoneChest) {
					stoneGathered += puck.getStoneCurrentlyHeld();
					puck.setStoneCurrentlyHeld(0);
				}

				puck.setGoldCurrentlyHeld(puck.getGoldCurrentlyHeld() - 1);
				puck.setSprite(1);

				// If you have no gold at the base, or have gold at the mine: travel to the
				// other one
			} else if ((puck.getGoldCurrentlyHeld() < 1 && puck.overlaps(baseLeft))) {
				puck.setTargetX((int) (targetBuilding.x + targetBuilding.width / 2));
				puck.setTargetY((int) (targetBuilding.y + targetBuilding.height / 2));
			} else if ((puck.getGoldCurrentlyHeld() > 0 && puck.overlaps(targetBuilding))) {
				puck.setTargetX((int) (baseLeft.x + baseLeft.width / 2));
				puck.setTargetY((int) (baseLeft.y + baseLeft.height / 2));
			}

		}

		if (targetBuilding == stoneChest) {

			if (puck.getStoneCurrentlyHeld() < 1 && !puck.overlaps(targetBuilding)) {
				puck.setTargetX((int) (targetBuilding.x + targetBuilding.width / 2));
				puck.setTargetY((int) (targetBuilding.y + targetBuilding.height / 2));
			} else if (puck.getStoneCurrentlyHeld() > 0 && !puck.overlaps(baseLeft)) {
				puck.setTargetX((int) (baseLeft.x + baseLeft.width / 2));
				puck.setTargetY((int) (baseLeft.y + baseLeft.height / 2));

				// If you no gold at the mine, or have gold at the base: mine/deposit it
			} else if ((puck.getStoneCurrentlyHeld() < 1 && puck.overlaps(targetBuilding))) {

				puck.setStoneCurrentlyHeld(puck.getStoneCurrentlyHeld() + 1);
				puck.setSprite(2);
			} else if ((puck.getStoneCurrentlyHeld() > 0 && puck.overlaps(baseLeft))) {

				stoneGathered += puck.getStoneCurrentlyHeld();
				puck.setStoneCurrentlyHeld(0);
				puck.setStoneCurrentlyHeld(puck.getStoneCurrentlyHeld() - 1);
				puck.setSprite(1);

				// If you have no gold at the base, or have gold at the mine: travel to the
				// other one
			} else if ((puck.getStoneCurrentlyHeld() < 1 && puck.overlaps(baseLeft))) {
				puck.setTargetX((int) (targetBuilding.x + targetBuilding.width / 2));
				puck.setTargetY((int) (targetBuilding.y + targetBuilding.height / 2));
			} else if ((puck.getStoneCurrentlyHeld() > 0 && puck.overlaps(targetBuilding))) {
				puck.setTargetX((int) (baseLeft.x + baseLeft.width / 2));
				puck.setTargetY((int) (baseLeft.y + baseLeft.height / 2));
			}

		}

		homeIn(puck);
	}

	private void homeIn(PuckRootClass puck) {

		if (puck.getTargetX() != 0) {

			if (puck.x < puck.getTargetX()) {
				puck.x += movementSpeed;
			} else {
				puck.x -= movementSpeed;
			}
		}

		if (puck.getTargetY() != 0) {
			if (puck.y < puck.getTargetY()) {
				puck.y += movementSpeed;
			} else {
				puck.y -= movementSpeed;
			}

		}

	}

	private void followInputs(PuckRootClass puck) {

		if (Gdx.input.isKeyPressed(Input.Keys.S)) {
			if (puck.y >= 55) {
				puck.y -= movementSpeed;
			}
		}
		if (Gdx.input.isKeyPressed(Input.Keys.W)) {
			if (puck.y < 500) {
				puck.y += movementSpeed;
			}
		}
		if (Gdx.input.isKeyPressed(Input.Keys.A)) {
			if (puck.x - movementSpeed + puck.getWidth() / 2 >= 0) {
				puck.x -= movementSpeed;
			}
		}
		if (Gdx.input.isKeyPressed(Input.Keys.D)) {
			if (puck.x <= background.getWidth() - 50) {
				puck.x += movementSpeed;
			}
		}

	}

//	private void performActionsRight(PuckRootClass puck) {
//		// TODO Auto-generated method stub
//
//	}

	private void assignPuckAction() {

		for (PuckRootClass puck : leftTeam) {

			if (currentInputsLeft.equals(Integer.toString(puck.getNumber()))) {

				// TODO Remove code bloat.

				// Harvest gold from mine
				if (Gdx.input.isKeyPressed(Input.Keys.Q)) {
					puck.setCurrentAction("MineGold");

					// Harvest stone from mine
				} else if (Gdx.input.isKeyPressed(Input.Keys.E)) {
					puck.setCurrentAction("GatherStone");

					// Attack nearest enemy
				} else if (Gdx.input.isKeyPressed(Input.Keys.R)) {
					puck.setCurrentAction("AttackNearest");

					// Build BasicTower in current location
				} else if (Gdx.input.isKeyPressed(Input.Keys.T)) {
					puck.setCurrentAction("Build-BasicTower");
//					TODO Implement this ^^^^

				} else if (Gdx.input.isKeyPressed(Input.Keys.B)) {

					puck.setCurrentAction("Build-BarbedWire");

					// Move to 100/200/300
				} else if (Gdx.input.isKeyPressed(Input.Keys.R)) {
					puck.setCurrentAction("Move300");
				} else if (Gdx.input.isKeyPressed(Input.Keys.F)) {
					puck.setCurrentAction("Move200");
				} else if (Gdx.input.isKeyPressed(Input.Keys.C)) {
					puck.setCurrentAction("Move100");

					// Wipes current input
				} else if (Gdx.input.isKeyPressed(Input.Keys.ESCAPE)) {
					puck.setCurrentAction("");

					// If nothing else pressed, puck will follow user inputs:
				} else {
					puck.setCurrentAction("FollowInputs");
				}

			}

		}
	}

	private void check123Pressed() {

		currentInputsLeft = "";
//		currentInputsRight = "";

		// TODO Get these to refer to a enum of input + appropriate method for each team

		// For left player
		if (Gdx.input.isKeyJustPressed(Input.Keys.NUMPAD_1)) {

			currentInputsLeft = "1";
		}
		if (Gdx.input.isKeyJustPressed(Input.Keys.NUMPAD_2)) {
			currentInputsLeft = "2";
		}
		if (Gdx.input.isKeyJustPressed(Input.Keys.NUMPAD_3)) {
			currentInputsLeft = "3";
		}

		// For right player
//		if (Gdx.input.isKeyPressed(Input.Keys.NUMPAD_1)) {
//			currentInputsRight = "1";
//		}
//		if (Gdx.input.isKeyPressed(Input.Keys.NUMPAD_2)) {
//			currentInputsRight = "2";
//		}
//		if (Gdx.input.isKeyPressed(Input.Keys.NUMPAD_3)) {
//			currentInputsRight = "3";
//		}

	}

	private void drawGameUnits() {

		batch.draw(background, 0, 0);

		batch.draw(baseLeft.getBackground(), baseLeft.x, baseLeft.y + baseLeft.getHeight() / 2);
//		batch.draw(baseRight.getBackground(), baseRight.x, baseRight.y);

		batch.draw(mineLeft.getBackground(), mineLeft.x, mineLeft.y);
//		batch.draw(mineRight.getBackground(), mineRight.x, mineRight.y);

		batch.draw(stoneChest.getBackground(), stoneChest.x, stoneChest.y+stoneChest.getHeight()/2);

		for (PuckRootClass puck : leftTeam) {
			batch.draw(puck.getBackground(), puck.x + puck.getWidth() / 2, puck.y + puck.getHeight() / 2);
		}

//		for (PuckRootClass puck : rightTeam) {
//			batch.draw(puck.getBackground(), puck.x, puck.y);
//		}

	}

	@Override
	public void resize(int width, int height) {
		// TODO Auto-generated method stub

	}

	@Override
	public void pause() {
		// TODO Auto-generated method stub

	}

	@Override
	public void resume() {
		// TODO Auto-generated method stub

	}

	@Override
	public void hide() {
		// TODO Auto-generated method stub

	}

	@Override
	public void dispose() {
		// TODO Auto-generated method stub

	}

// Helper methods

	public void createAllElements() {

		leftTeam = new ArrayList<PuckRootClass>();
		leftTeam.add(puckLeft1 = new PuckRootClass("LEFT", 1, "puck1"));
		leftTeam.add(puckLeft1 = new PuckRootClass("LEFT", 2, "puck2"));
		leftTeam.add(puckLeft1 = new PuckRootClass("LEFT", 3, "puck3"));
		baseLeft = new BaseRootClass("LEFT", this);
		mineLeft = new MineRootClass("LEFT", 80, 150);
		// TODO Rename this, change name, etc
		stoneChest = new StoneChest("LEFT", 80, 400);
		

		


//		rightTeam = new ArrayList<PuckRootClass>();
//		rightTeam.add(puckRight1 = new PuckRootClass("RIGHT", 1));
//		rightTeam.add(puckRight1 = new PuckRootClass("RIGHT", 2));
//		rightTeam.add(puckRight1 = new PuckRootClass("RIGHT", 3));
//		baseRight = new BaseRootClass("RIGHT", 600, 50);
//		mineRight = new MineRootClass("RIGHT", 600, 300);

	}

	private void addStartingTowers() {
		
		BasicTower basicStarterTower1 = new BasicTower();
		basicStarterTower1.x = background.getWidth()/5*3;
		basicStarterTower1.y = background.getHeight()/2 + basicStarterTower1.getHeight();
		levelManager.getTowersInPlay().add(basicStarterTower1);
		
		Barbs starterBarbs1 = new Barbs();
		starterBarbs1.x = basicStarterTower1.x + basicStarterTower1.getWidth();
		starterBarbs1.y = basicStarterTower1.y;
		levelManager.getTowersInPlay().add(starterBarbs1);
		
		BasicTower basicStarterTower2 = new BasicTower();
		basicStarterTower2.x = background.getWidth()/5*3;
		basicStarterTower2.y = background.getHeight()/2 - basicStarterTower2.getHeight()*2;
		levelManager.getTowersInPlay().add(basicStarterTower2);
		
		Barbs starterBarbs2 = new Barbs();
		starterBarbs2.x = basicStarterTower2.x + basicStarterTower2.getWidth();
		starterBarbs2.y = basicStarterTower2.y;
		levelManager.getTowersInPlay().add(starterBarbs2);

	}

	public void setUpThings() {

		currentInputsLeft = "";
//		currentInputsRight = "";

		batch = new SpriteBatch();
		font = new BitmapFont();

		camera = new OrthographicCamera(100, 100);
		viewport = new FitViewport(100, 100, camera);

		movementSpeed = 2;

		leftTeamGold = 5;
//		rightTeamGold = 100;

		// Stone collected
		stoneGathered = 10;

		// Single-player lives
		lives = 10;

		// TODO How make this scale to game units?
		background = new Texture(Gdx.files.internal("backgroundLarge.png"));
	}

	public void assignStartingPositions(ArrayList<PuckRootClass> pucks) {

		// TODO This, and everywhere else, set these numbers to variables to reference

		for (PuckRootClass puck : pucks) {
			if (puck.getNumber() == 1) {
				puck.y = background.getHeight() / 4 * 3;
			}
			if (puck.getNumber() == 2) {
				puck.y = background.getHeight() / 4 * 2;
			}
			if (puck.getNumber() == 3) {
				puck.y = background.getHeight() / 4;
			}

			if (puck.getTeam().equals("LEFT")) {
				puck.x = background.getWidth() / 5;
			} else {
				puck.x = background.getWidth() / 5 * 4;
			}

		}

	}

// Getters and Setters

	public int getLives() {
		return lives;
	}

	public void setLives(int lives) {
		this.lives = lives;
	}

	public Texture getBackground() {
		return background;
	}

	public void setBackground(Texture background) {
		this.background = background;
	}

}